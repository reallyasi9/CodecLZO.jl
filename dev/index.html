<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CodecLZO.jl</title><meta name="title" content="Home · CodecLZO.jl"/><meta property="og:title" content="Home · CodecLZO.jl"/><meta property="twitter:title" content="Home · CodecLZO.jl"/><meta name="description" content="Documentation for CodecLZO.jl."/><meta property="og:description" content="Documentation for CodecLZO.jl."/><meta property="twitter:description" content="Documentation for CodecLZO.jl."/><meta property="og:url" content="https://reallyasi9.github.io/CodecLZO.jl/"/><meta property="twitter:url" content="https://reallyasi9.github.io/CodecLZO.jl/"/><link rel="canonical" href="https://reallyasi9.github.io/CodecLZO.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CodecLZO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/reallyasi9/CodecLZO.jl/blob/development/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CodecLZO"><a class="docs-heading-anchor" href="#CodecLZO">CodecLZO</a><a id="CodecLZO-1"></a><a class="docs-heading-anchor-permalink" href="#CodecLZO" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/reallyasi9/CodecLZO.jl">CodecLZO</a>.</p><ul><li><a href="#CodecLZO.AbstractCommand"><code>CodecLZO.AbstractCommand</code></a></li><li><a href="#CodecLZO.HashMap"><code>CodecLZO.HashMap</code></a></li><li><a href="#CodecLZO.HistoryCopyCommand"><code>CodecLZO.HistoryCopyCommand</code></a></li><li><a href="#CodecLZO.LZO1X1CompressorCodec"><code>CodecLZO.LZO1X1CompressorCodec</code></a></li><li><a href="#CodecLZO.LZO1X1DecompressorCodec"><code>CodecLZO.LZO1X1DecompressorCodec</code></a></li><li><a href="#CodecLZO.LZO1X1FastCompressorCodec"><code>CodecLZO.LZO1X1FastCompressorCodec</code></a></li><li><a href="#CodecLZO.LZO1X1FastDecompressorCodec"><code>CodecLZO.LZO1X1FastDecompressorCodec</code></a></li><li><a href="#CodecLZO.LiteralCopyCommand"><code>CodecLZO.LiteralCopyCommand</code></a></li><li><a href="#CodecLZO.ModuloBuffer"><code>CodecLZO.ModuloBuffer</code></a></li><li><a href="#CodecLZO.PassThroughFIFO"><code>CodecLZO.PassThroughFIFO</code></a></li><li><a href="#Base.resize!-Union{Tuple{T}, Tuple{CodecLZO.ModuloBuffer{T}, Integer}} where T"><code>Base.resize!</code></a></li><li><a href="#CodecLZO.capacity-Tuple{CodecLZO.ModuloBuffer}"><code>CodecLZO.capacity</code></a></li><li><a href="#CodecLZO.command_length-Tuple{CodecLZO.AbstractCommand}"><code>CodecLZO.command_length</code></a></li><li><a href="#CodecLZO.compute_run_remainder-Tuple{Integer, Integer}"><code>CodecLZO.compute_run_remainder</code></a></li><li><a href="#CodecLZO.copy_length-Tuple{CodecLZO.AbstractCommand}"><code>CodecLZO.copy_length</code></a></li><li><a href="#CodecLZO.count_matching-Tuple{Any, Integer, Any, Integer}"><code>CodecLZO.count_matching</code></a></li><li><a href="#CodecLZO.decode_run-Tuple{AbstractVector{UInt8}, Integer}"><code>CodecLZO.decode_run</code></a></li><li><a href="#CodecLZO.encode_run!-Tuple{AbstractVector{UInt8}, Integer, Integer}"><code>CodecLZO.encode_run!</code></a></li><li><a href="#CodecLZO.flush!-Tuple{CodecLZO.PassThroughFIFO, AbstractVector{UInt8}}"><code>CodecLZO.flush!</code></a></li><li><a href="#CodecLZO.lzo_compress"><code>CodecLZO.lzo_compress</code></a></li><li><a href="#CodecLZO.lzo_compress!"><code>CodecLZO.lzo_compress!</code></a></li><li><a href="#CodecLZO.lzo_decompress-Tuple{AbstractVector{UInt8}}"><code>CodecLZO.lzo_decompress</code></a></li><li><a href="#CodecLZO.lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.lzo_decompress!</code></a></li><li><a href="#CodecLZO.multiplicative_hash-Union{Tuple{T}, Tuple{T, Integer, Int64}} where T&lt;:Integer"><code>CodecLZO.multiplicative_hash</code></a></li><li><a href="#CodecLZO.pushout!-Tuple{CodecLZO.PassThroughFIFO, AbstractVector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.pushout!</code></a></li><li><a href="#CodecLZO.reinterpret_get-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Integer}} where T&lt;:Integer"><code>CodecLZO.reinterpret_get</code></a></li><li><a href="#CodecLZO.reinterpret_next-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Integer}} where T&lt;:Integer"><code>CodecLZO.reinterpret_next</code></a></li><li><a href="#CodecLZO.repeatout!-Tuple{CodecLZO.PassThroughFIFO, Integer, Integer, AbstractVector{UInt8}}"><code>CodecLZO.repeatout!</code></a></li><li><a href="#CodecLZO.replace_all_matching!-Union{Tuple{V}, Tuple{K}, Tuple{CodecLZO.HashMap{K, V}, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64}} where {K&lt;:Integer, V}"><code>CodecLZO.replace_all_matching!</code></a></li><li><a href="#CodecLZO.resize_front!-Tuple{CodecLZO.ModuloBuffer, Integer}"><code>CodecLZO.resize_front!</code></a></li><li><a href="#CodecLZO.shift_copy!"><code>CodecLZO.shift_copy!</code></a></li><li><a href="#CodecLZO.state-Tuple{LZO1X1CompressorCodec}"><code>CodecLZO.state</code></a></li><li><a href="#CodecLZO.unsafe_decode_run-Tuple{Ptr{UInt8}, Integer, Integer}"><code>CodecLZO.unsafe_decode_run</code></a></li><li><a href="#CodecLZO.unsafe_encode_run!"><code>CodecLZO.unsafe_encode_run!</code></a></li><li><a href="#CodecLZO.unsafe_lzo_compress!"><code>CodecLZO.unsafe_lzo_compress!</code></a></li><li><a href="#CodecLZO.unsafe_lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.unsafe_lzo_decompress!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.AbstractCommand" href="#CodecLZO.AbstractCommand"><code>CodecLZO.AbstractCommand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractCommand</code></pre><p>A type representing either a literal copy (<code>LiteralCopyCommand</code>) or a history lookback copy (<code>HistoryCopyCommand</code>).</p><p>Types that inherit from <code>AbstractCommand</code> must implement the following methods:</p><ul><li><code>command_length(::AbstractCommand)::Int</code>, which returns the length of the encoded command in bytes;</li><li><code>copy_length(::AbstractCommand)::Int</code>, which returns the number of bytes to be copied to the output;</li><li>one or both of:<ul><li><code>decode(::Type{T}, ::AbstractVector{UInt8})::T where {T &lt;: AbstractCommand}</code>, which decodes a command of type <code>T</code> from the start of an <code>AbstractVector{UInt8}</code>;</li><li><code>unsafe_decode(::Type{T}, ::Ptr{UInt8}, ::Integer)::T where {T &lt;: AbstractCommand}</code>, which decodes a command of type <code>T</code> from the memory pointed to by the pointer at a given (one-indexed) offset;</li></ul></li><li>one or both of:<ul><li><code>encode!(::T, ::AbstractCommand)::T where {T &lt;: AbstractVector{UInt8}}</code>, which encodes the command to the given vector and returns the modified vector;</li><li><code>unsafe_encode!(::Ptr{UInt8}, ::AbstractCommand, ::Integer)::Int</code>, which encodes the command to the memory pointed to at a given (one-indexed offset) and returns the number of bytes written.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.HashMap" href="#CodecLZO.HashMap"><code>CodecLZO.HashMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HashMap{K,V}</code></pre><p>A super-fast dictionary-like hash table of fixed size for integer keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/hashmap.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.HistoryCopyCommand" href="#CodecLZO.HistoryCopyCommand"><code>CodecLZO.HistoryCopyCommand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HistoryCopyCommand &lt;: AbstractCommand</code></pre><p>An encoded command representing a copy of a number of bytes from the already produced output back to the output.</p><p>In LZO1X, history lookback copies come in five varieties, the format of which is determined by the number of bytes copied, the lookback distance, and whether or not the previous command had a short literal copy tagged on the end:</p><p><strong>Very short copy, short distance</strong></p><p>Copies of three to four bytes with a lookback distance within 2048 bytes are encoded as two bytes, with bits encoding the length and distance. The command is to be interpreted in the following way (MSB first):</p><pre><code class="nohighlight hljs">`01LDDDSS HHHHHHHH`</code></pre><p>This means copy <code>3 + 0bL</code> from a distance of <code>0b00000HHH_HHHHHDDD + 1</code>.</p><p>The last two bits of the MSB instruct the decoder to copy <code>0bSS</code> literals from the input to the output immediately following the history lookback copy.</p><p><strong>Short copy, short distance</strong></p><p>Copies of five to eight bytes with a lookback distance within 2048 bytes are encoded as two bytes, with bits encoding the length and distance. The command is to be interpreted in the following way (MSB first):</p><pre><code class="nohighlight hljs">`1LLDDDSS HHHHHHHH`</code></pre><p>This means copy <code>5 + 0bLL</code> bytes from a distance of <code>0b00000HHH_HHHHHDDD + 1</code>.</p><p>The last two bits of the MSB instruct the decoder to copy 0 through 3 literals from the input to the output immediately following the history lookback copy.</p><p><strong>Any length copy, short to medium distance</strong></p><p>Copies of any length greater than two with a lookback distance within 16384 bytes is incoded with at least three bytes and with as many as necessary to encode the run length. The command is to be interpreted in the following way (MSB first):</p><pre><code class="nohighlight hljs">`001LLLLL [Z zero bytes] [XXXXXXXX] EEEEEESS DDDDDDDD`</code></pre><p>The lower five bits of the first byte represent the length of the copy <em>minus two</em>. This can obviously only represent copies of length 2 to 33, so to encode longer copies, LZO1X uses the following encoding method:</p><ol><li>If <code>0bLLLLL</code> is non-zero, then <code>length = 2 + 0bLLLLL</code></li><li>If <code>0bLLLLL</code> is zero, then <code>length = 33 + (number of zero bytes after the first) × 255 + (first non-zero byte)</code></li></ol><p>The lookback distance is encoded in LE order in the last two bytes: that is, the last byte of the command holds the MSB of the distance, and the second-to-last byte holds the LSB of the distance. The distance is interpreted as <code>distance = 0b00DDDDDD_DDEEEEEE + 1</code>.</p><p>The last two bits of the second-to-last byte instruct the decoder to copy <code>0bSS</code> literals from the input to the output immediately following the history lookback copy.</p><p><strong>Any length copy, long distance</strong></p><p>Copies of any length greater than two with a lookback distance between 16385 and 49151 bytes is incoded with at least three bytes and with as many as necessary to encode the run length. The command is to be interpreted in the following way (MSB first):</p><pre><code class="nohighlight hljs">`0001HLLL [Z zero bytes] [XXXXXXXX] EEEEEESS DDDDDDDD`</code></pre><p>As with other variable length runs,, LZO1X uses the following encoding method with this command:</p><ol><li>If <code>0bLLL</code> is non-zero, then <code>length = 2 + 0bLLL</code></li><li>If <code>0bLLL</code> is zero, then <code>length = 9 + (number of zero bytes after the first) × 255 + (first non-zero byte)</code></li></ol><p>The lookback distance is encoded with one bit in the first command byte (<code>H</code>), then in LE order in the last two bytes: that is, the last byte of the command holds the MSB of the distance, and the second-to-last byte holds the LSB of the distance. The distance is interpreted as <code>distance = 16384 + 0b0HDDDDDD_DDEEEEEE</code>.</p><p>The last two bits of the second-to-last byte instruct the decoder to copy <code>0bSS</code> literals from the input to the output immediately following the history lookback copy.</p><div class="admonition is-info"><header class="admonition-header">Special End-of-Stream Encoding</header><div class="admonition-body"><p>End-of-stream is signaled by a history lookback copy of 3 bytes from a distance of 16384 bytes with no subsequent literal copies. This corresponds to a long historical lookback copy command of <code>0b00010001 0b00000000 0b00000000</code>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The maximum lookback distance that LZO1X can encode is <code>16384 + 0b01111111_11111111 == 49151</code> bytes.</p></div></div><p><strong>Short copies from short distances following literal copies</strong></p><p>If the previous history lookback command included a short literal copy (<code>1 ≤ 0bSS ≤ 3</code>, as encoded in the above commands), then a special two-byte command can be used to copy two bytes with a lookback distance within 1024 bytes. The command is to be interpreted in the following way (MSB first):</p><pre><code class="nohighlight hljs">`0000DDSS HHHHHHHH`</code></pre><p>The number of bytes to copy is always <code>length = 2</code>, and the lookback distance is <code>0b000000HH_HHHHHHDD + 1</code>.</p><p>The last two bits of the first byte instruct the decoder to copy <code>0bSS</code> literals from the input to the output immediately following the history lookback copy.</p><p>If the previous command was a long literal copy (of four of more bytes), then the same two-byte command means something different: it encodes a three-byte copy with a lookback distance between 2049 and 3071 bytes. The command is interpreted the same as above, but <code>length = 3</code> and <code>distance = 0b000000HH_HHHHHHDD + 2049</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Because encoding these special commands require a historical match of fewer than four bytes, they are never <em>encoded</em> by the LZO1X algorithm: however, they are valid LZO1X commands, and the LZO1X <em>decoder</em> will interpret them correctly.</p></div></div><p>See also <a href="#CodecLZO.LiteralCopyCommand"><code>CodecLZO.LiteralCopyCommand</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L317-L396">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LZO1X1CompressorCodec" href="#CodecLZO.LZO1X1CompressorCodec"><code>CodecLZO.LZO1X1CompressorCodec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LZO1X1CompressorCodec(level::Int=5) &lt;: TranscodingStreams.Codec</code></pre><p>A struct that compresses data according to the 1X1 version of the LZO algorithm.</p><p>The LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm defined by:</p><ul><li>A lookback dictionary implemented as a hash map with a maximum of size of <code>1&lt;&lt;12 = 4096</code> elements;</li><li>A 4-byte history lookup window that scans the input with a skip distance that increases linearly with the number of misses;</li><li>A maximum lookback distance of <code>0b11000000_00000000 - 1 = 49151</code> bytes;</li></ul><p>The C implementation of LZO defined by liblzo2 requires that all compressable information be loaded in working memory at once, and is therefore not adaptable to streaming as required by TranscodingStreams. The C library version claims to use only a 4096-byte hash map as additional working memory, but it also requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable <em>a priori</em> but can be larger than the uncompressed data by a factor of roughly 256/255. This implementation needs to keep 49151 bytes of input history in memory in addition to the 4096-byte hash map, but only expands the output as necessary during compression.</p><p>Arguments:</p><ul><li><code>level::Int = 5</code>: The speed/compression tradeoff paramter, with larger numbers representing slower compression at a higher compresison ratio. On a technical level, every <code>pow(2, level)</code> history misses increases by 1 the number of bytes skipped when searching for the next history match. The default (5) is recommended by the original liblzo2 authors as a good balance between speed and compression.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_stream_compression.jl#L22-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LZO1X1DecompressorCodec" href="#CodecLZO.LZO1X1DecompressorCodec"><code>CodecLZO.LZO1X1DecompressorCodec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LZO1X1DecompressorCodec &lt;: TranscodingStreams.Codec</code></pre><p>A struct that decompresses data according to the 1X1 version of the LZO algorithm.</p><p>The LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm. Compressed streams consist of alternating encoded instructions and sequences of literal values. The encoded instructions tell the decompressor to either:</p><ol><li>copy a sequence of bytes of a particular length directly from the input to the output (literal copy), or</li><li>look back a certain distance in the already returned output and copy a sequence of bytes of a particular length from the output to the output again.</li></ol><p>For implementation purposes, this decompressor uses a buffer of 49151 bytes to store output. This is equal to the maximum lookback distance of the LZO 1X1 algorithm.</p><p>The C implementation of LZO defined by liblzo2 requires that all decompressed information be available in working memory at once, and is therefore not adaptable to streaming as required by TranscodingStreams. The C library version claims to use no additional working memory, but it requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable <em>a priori</em> but can be larger than the compressed data by a factor of roughly 255. This implementation needs to keep 49151 bytes of output history in memory while decompressing, equal to the maximum lookback distance of the LZO 1x1 algorithm, and a small number of bytes to keep track of the command being processed in case the command is broken between multiple reads from the input memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_stream_decompression.jl#L10-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LZO1X1FastCompressorCodec" href="#CodecLZO.LZO1X1FastCompressorCodec"><code>CodecLZO.LZO1X1FastCompressorCodec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LZO1X1FastCompressorCodec &lt;: TranscodingStreams.Codec</code></pre><p>A struct that compresses data using the liblzo2 version version of the LZO 1X1 algorithm.</p><p>The LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm defined by:</p><ul><li>A lookback dictionary implemented as a hash map with a maximum of size of <code>1&lt;&lt;16 = 65536</code> elements;</li><li>A 4-byte history lookup window that scans the input with a skip distance that increases linearly with the number of misses;</li><li>A maximum lookback distance of <code>0b11000000_00000000 - 1 = 49151</code> bytes;</li></ul><p>The C implementation of LZO defined by liblzo2 requires that all compressable information be loaded in working memory at once. The C library version claims to use only a 4096-byte hash map as additional working memory, but it also requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable <em>a priori</em> but can be larger than the uncompressed data by a factor of roughly 256/255. This implementation uses an expanding input buffer that waits until all input is available before processing, eliminating the usefulness of the TranscodingStreams interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_fast_compression.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LZO1X1FastDecompressorCodec" href="#CodecLZO.LZO1X1FastDecompressorCodec"><code>CodecLZO.LZO1X1FastDecompressorCodec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LZO1X1FastDecompressorCodec &lt;: TranscodingStreams.Codec</code></pre><p>A struct that decompresses data using liblzo1 library version of the LZO 1X1 algorithm.</p><p>The LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm. Compressed streams consist of alternating encoded instructions and sequences of literal values. The encoded instructions tell the decompressor to either:</p><ol><li>copy a sequence of bytes of a particular length directly from the input to the output (literal copy), or</li><li>look back a certain distance in the already returned output and copy a sequence of bytes of a particular length from the output to the output again.</li></ol><p>The C implementation of LZO defined by liblzo2 requires that all decompressed information be available in working memory at once, and therefore does not take advantage of the memory savings allowed by TranscodingStreams. The C library version claims to use no additional working memory, but it requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable <em>a priori</em> but can be larger than the compressed data by a factor of roughly 255. This implementation reports a very large memory requirement with <code>TranscodingStreams.minoutsize</code> to account for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_fast_decompression.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LiteralCopyCommand" href="#CodecLZO.LiteralCopyCommand"><code>CodecLZO.LiteralCopyCommand</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct LiteralCopyCommand &lt;: AbstractCommand</code></pre><p>An encoded command representing a copy of a number of bytes from input straight to output.</p><p>In LZO1X, literal copies come in three varieties:</p><p><strong>Long copies</strong></p><p>LZO1X long copy commands begin with a byte with four high zero bits and four low potentially non-zero bits:</p><pre><code class="nohighlight hljs">0 0 0 0 L L L L</code></pre><p>The low four bits represent the length of the copy <em>minus three</em>. This can obviously only represent copies of length 3 to 18, so to encode longer copies, LZO1X uses the following encoding method:</p><ol><li>If the first byte is non-zero, then <code>length = 3 + L</code></li><li>If the first byte is zero, then <code>length = 18 + (number of zero bytes after the first) × 255 + (first non-zero byte)</code></li></ol><p>This means a length of 18 is encoded as <code>[0b00001111]</code>, a length of 19 is encoded as <code>[0b00000000, 0b00000001]</code>, a length of 274 is encoded as <code>[0b00000000, 0b00000000, 0b00000001]</code>, and so on.</p><p><strong>Short copies</strong></p><p>The long copy command cannot encode copies shorter than four bytes by design. If a literal of three or fewer bytes needs to be copied, it is encoded in the two least significant bits of the previous history lookback copy command. This works because literal copies and history lookback copies always alternate in LZO1X streams.</p><p><strong>First literal copies</strong></p><p>LZO1X streams always begin with a literal copy command of at least four bytes. Because the first command is always a literal copy, a special format is used to copy runs of literals that are between 18 and 238 bytes that compacts the command into a single byte. If the first byte of the stream has the following values, they are interpreted as the corresponding literal copy commands:</p><ul><li><code>0:15</code>: Treat as a &quot;long copy&quot; encoding (see above).</li><li><code>17:255</code>: Treat as a copy of <code>(byte - 17)</code> literals.</li></ul><p>Note that <code>17:20</code> are invalid values for a first copy command in LZO1X streams because history lookback copy lengths must always be four or more bytes. A value of <code>16</code> in the first position is always invalid.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The official <code>liblzo2</code> version of LZO1X properly <em>decodes</em> these first literal copy codes, but never <em>encodes</em> them when compressing data.</p></div></div><p>See also <a href="#CodecLZO.HistoryCopyCommand"><code>CodecLZO.HistoryCopyCommand</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L152-L189">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.ModuloBuffer" href="#CodecLZO.ModuloBuffer"><code>CodecLZO.ModuloBuffer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModuloBuffer{T}(n::Integer)
ModuloBuffer(iter)</code></pre><p>An <code>AbstractVector{T}</code> of fixed capacity <code>n</code> with periodic boundary conditions on the index.</p><p>The first version of the constructor will create an empty buffer with a capacity of <code>n</code>. The second version will copy all elements of the iterable object <code>iter</code> into a new buffer with a capacity of <code>length(iter)</code> and element type <code>eltype(iter)</code>.</p><p>If a new element added (either with <code>push!</code>, <code>pushfirst!</code>, <code>append!</code>, or <code>prepend!</code>) would increase the size of the buffer past the capacity, the oldest element added will be overwritten (or the newest element added in the case of <code>pushfirst!</code> or <code>prepend!</code>) to maintain the fixed capacity.</p><p>If the buffer is not at capacity, then attempts to index into unfilled elements of the buffer will result in a <code>BoundsError</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/modulobuffer.jl#L2-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.PassThroughFIFO" href="#CodecLZO.PassThroughFIFO"><code>CodecLZO.PassThroughFIFO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PassThroughFIFO &lt;: AbstractVector{UInt8}</code></pre><p>A FIFO (first in, first out data structure) that buffers data pushed into the front of it and, when full, pushes out older data from the back to a sink.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/passthroughfifo.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.resize!-Union{Tuple{T}, Tuple{CodecLZO.ModuloBuffer{T}, Integer}} where T" href="#Base.resize!-Union{Tuple{T}, Tuple{CodecLZO.ModuloBuffer{T}, Integer}} where T"><code>Base.resize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize!(buffer::ModuloBuffer, n::Integer)::ModuloBuffer</code></pre><p>Resize <code>buffer</code> to a capacity of <code>n</code> elements by adjusting the location of the back of the buffer.</p><p>If <code>n &lt; capacity(buffer)</code>, only the first <code>n</code> elements of <code>buffer</code> will be retained.</p><p>Attempts to avoid allocating new memory by manipulating and resizing the internal vector in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/modulobuffer.jl#L147-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.capacity-Tuple{CodecLZO.ModuloBuffer}" href="#CodecLZO.capacity-Tuple{CodecLZO.ModuloBuffer}"><code>CodecLZO.capacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">capacity(buffer::ModuloBuffer)::Int</code></pre><p>Return the maximum number of elements <code>buffer</code> can contain.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/modulobuffer.jl#L124-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.command_length-Tuple{CodecLZO.AbstractCommand}" href="#CodecLZO.command_length-Tuple{CodecLZO.AbstractCommand}"><code>CodecLZO.command_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">command_length(command)::Int</code></pre><p>Return the number of bytes in the encoded <code>command</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L24-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.compute_run_remainder-Tuple{Integer, Integer}" href="#CodecLZO.compute_run_remainder-Tuple{Integer, Integer}"><code>CodecLZO.compute_run_remainder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">compute_run_remainder(n, bits)::Tuple{Int, Int}</code></pre><p>Compute the number of bytes necessary to encode a run of length <code>n</code> given a first-byte mask of length <code>bits</code>, also returning the remainder byte.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This method does not adjust <code>n</code> before computing the run length. Perform adjustments before calling this method.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L217-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.copy_length-Tuple{CodecLZO.AbstractCommand}" href="#CodecLZO.copy_length-Tuple{CodecLZO.AbstractCommand}"><code>CodecLZO.copy_length</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">copy_length(command)::Int</code></pre><p>Return the number of bytes that are to be copied to the output by <code>command</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.count_matching-Tuple{Any, Integer, Any, Integer}" href="#CodecLZO.count_matching-Tuple{Any, Integer, Any, Integer}"><code>CodecLZO.count_matching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_matching(a::AbstractVector, b::AbstractVector)</code></pre><p>Count the number of elements at the start of <code>a</code> that match the elements at the start of <code>b</code>.</p><p>Equivalent to <code>findfirst(a .!= b)</code>, but faster and limiting itself to the first <code>min(length(a), length(b))</code> elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/memory_management.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.decode_run-Tuple{AbstractVector{UInt8}, Integer}" href="#CodecLZO.decode_run-Tuple{AbstractVector{UInt8}, Integer}"><code>CodecLZO.decode_run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decode_run(input::Vector{UInt8}, bits)::Tuple{Int, Int}</code></pre><p>Decode the length of the run in bytes and the number of bytes to copy from <code>input</code> given a mask of <code>bits</code> bits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.encode_run!-Tuple{AbstractVector{UInt8}, Integer, Integer}" href="#CodecLZO.encode_run!-Tuple{AbstractVector{UInt8}, Integer, Integer}"><code>CodecLZO.encode_run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">encode_run!(output, len, bits)::Int</code></pre><p>Emit the number of zero bytes necessary to encode a length <code>len</code> in a command expecting <code>bits</code> leading bits, returning the number of bytes written to the output.</p><p>Literal and copy lengths are always encoded as either a single byte or a sequence of three or more bytes. If <code>len &lt; (1 &lt;&lt; bits)</code>, the length will be encoded in the lower <code>bits</code> bits of the starting byte of <code>output</code> so the return will be 0. Otherwise, the return will be the number of additional bytes needed to encode the length. The returned number of bytes does not include the zeros in the first byte (the command) used to signal that a run encoding follows, but it does include the remainder.</p><p>Note: the argument <code>len</code> is expected to be the <em>adjusted length</em> for the command. Literals use an adjusted length of <code>len = length(literal) - 3</code> and copy commands use an adjusted literal length of <code>len = length(copy) - 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L46-L54">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.flush!-Tuple{CodecLZO.PassThroughFIFO, AbstractVector{UInt8}}" href="#CodecLZO.flush!-Tuple{CodecLZO.PassThroughFIFO, AbstractVector{UInt8}}"><code>CodecLZO.flush!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flush!(p::PassThroughFIFO, sink::AbstractVector{UInt8})</code></pre><p>Copy all the data in <code>p</code> to the front of <code>sink</code>.</p><p>Returns the number of bytes copied, equal to <code>min(length(p), length(sink))</code>. If <code>length(sink) &gt;= length(p)</code>, <code>isempty(p) == true</code> after the flush, else <code>length(p)</code> will be equal to the number of bytes that could not be pushed to <code>sink</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/passthroughfifo.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.lzo_compress" href="#CodecLZO.lzo_compress"><code>CodecLZO.lzo_compress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lzo_compress(src, [working_memory=zeros(UInt8, 1&lt;&lt;12)])::Vector{UInt8}</code></pre><p>Compress <code>src</code> using the LZO 1X1 algorithm.</p><p>Returns a compressed version of <code>src</code>.</p><p>Pass <code>working_memory</code>, a <code>Vector{UInt8}</code> with <code>length(working_memory) &gt;= 1&lt;&lt;12</code>, to reuse pre-allocated memory required by the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_fast_compression.jl#L93-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.lzo_compress!" href="#CodecLZO.lzo_compress!"><code>CodecLZO.lzo_compress!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lzo_compress!(dest::Vector{UInt8}, src, [working_memory=zeros(UInt8, 1&lt;&lt;12)])</code></pre><p>Compress <code>src</code> to <code>dest</code> using the LZO 1X1 algorithm.</p><p>The destination vector <code>dest</code> will be resized to fit the compressed data if necessary. Returns the modified <code>dest</code>.</p><p>Pass <code>working_memory</code>, a <code>Vector{UInt8}</code> with <code>length(working_memory) &gt;= 1&lt;&lt;12</code>, to reuse pre-allocated memory required by the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_fast_compression.jl#L70-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}" href="#CodecLZO.lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.lzo_decompress!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lzo_decompress!(dest::Vector{UInt8}, src)</code></pre><p>Decompress <code>src</code> to <code>dest</code> using the LZO 1X1 algorithm.</p><p>The destination vector <code>dest</code> will be resized to fit the decompressed data if necessary. Returns the modified <code>dest</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_fast_decompression.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.lzo_decompress-Tuple{AbstractVector{UInt8}}" href="#CodecLZO.lzo_decompress-Tuple{AbstractVector{UInt8}}"><code>CodecLZO.lzo_decompress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lzo_decompress(src)::Vector{UInt8}</code></pre><p>Decompress <code>src</code> using the LZO 1X1 algorithm.</p><p>Returns a decompressed version of <code>src</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_fast_decompression.jl#L90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.multiplicative_hash-Union{Tuple{T}, Tuple{T, Integer, Int64}} where T&lt;:Integer" href="#CodecLZO.multiplicative_hash-Union{Tuple{T}, Tuple{T, Integer, Int64}} where T&lt;:Integer"><code>CodecLZO.multiplicative_hash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiplicative_hash(value, magic_number, bits, [mask::V = typemax(UInt64)])</code></pre><p>Hash <code>value</code> into a type <code>V</code> using multiplicative hashing.</p><p>This method performs <code>floor((value * magic_number % W) / (W / M))</code> where <code>W = 2^64</code>, <code>M = 2^m</code>, and <code>magic_number</code> is relatively prime to <code>W</code>, is large, and has a good mix of 1s and 0s in its binary representation. In modulo <code>2^64</code> arithmetic, this becomes <code>(value * magic_number) &gt;&gt;&gt; m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/hashmap.jl#L30-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.pushout!-Tuple{CodecLZO.PassThroughFIFO, AbstractVector{UInt8}, AbstractVector{UInt8}}" href="#CodecLZO.pushout!-Tuple{CodecLZO.PassThroughFIFO, AbstractVector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.pushout!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pushout!(p::PassThroughFIFO, source, sink::AbstractVector{UInt8})</code></pre><p>Push as much of <code>source</code> into the FIFO as it can hold, pushing out stored data to <code>sink</code>.</p><p>The argument <code>source</code> can be an <code>AbstractVector{UInt8}</code> or a single <code>UInt8</code> value.</p><p>Until <code>p</code> is full, elements from <code>source</code> will be added to the FIFO and no elements will be pushed out to <code>sink</code>. Once <code>p</code> is full, elements of <code>source</code> up to <code>capacity(p)</code> will be added to the FIFO and the older elements will be pushed to <code>sink</code>.</p><p>Returns a tuple of the number of elements read from <code>source</code> and the number of elements written to <code>sink</code>.</p><p>See <a href="#CodecLZO.repeatout!-Tuple{CodecLZO.PassThroughFIFO, Integer, Integer, AbstractVector{UInt8}}"><code>repeatout!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/passthroughfifo.jl#L41-L56">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.reinterpret_get-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Integer}} where T&lt;:Integer" href="#CodecLZO.reinterpret_get-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Integer}} where T&lt;:Integer"><code>CodecLZO.reinterpret_get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinterpret_get(T::Type, input, [index::Integer = 1])::T</code></pre><p>Reinterpret bytes from <code>input</code> as an LE-ordered value of type <code>T</code>, optionally starting at <code>index</code>. This tries to be faster than <code>reinterpret(T, input[index:index+sizeof(T)-1])</code>.</p><p><code>input</code> can be anything that is linearly indexed and <code>getindex(input, ::Int)</code> returns a type <code>S</code> for which the operator <code>|(::T, ::S)</code> is defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/memory_management.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.reinterpret_next-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Integer}} where T&lt;:Integer" href="#CodecLZO.reinterpret_next-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Integer}} where T&lt;:Integer"><code>CodecLZO.reinterpret_next</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinterpret_next(previous::T, input::AbstractVector{UInt8}, [index::Int = 1])::T</code></pre><p>Get the byte from <code>input</code> at <code>index</code> and push it to the LSB of <code>previous</code>, rotating off the MSB. This tries to be faster than doing <code>reinterpret(T, input[index:index+sizeof(T)-1])</code> twice by reusing the already read LSBs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/memory_management.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.repeatout!-Tuple{CodecLZO.PassThroughFIFO, Integer, Integer, AbstractVector{UInt8}}" href="#CodecLZO.repeatout!-Tuple{CodecLZO.PassThroughFIFO, Integer, Integer, AbstractVector{UInt8}}"><code>CodecLZO.repeatout!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeatout!(p::PassThroughFIFO, lookback::Integer, n::Integer, sink::AbstractVector{UInt8})</code></pre><p>Append <code>n</code> values starting from <code>lookback</code> bytes from the end of <code>p</code> to the front of <code>p</code>.</p><p>Once <code>p</code> is full, any bytes that are appended to the front of <code>p</code> will cause bytes from the back to be expelled into the front of <code>sink</code>.</p><p>This method works even if <code>n &gt; lookback</code>, in which case the bytes that were appended to the     front of <code>p</code> first will be repeated.</p><p>Returns the number of bytes expelled from <code>p</code> into <code>sink</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/passthroughfifo.jl#L96-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.replace_all_matching!-Union{Tuple{V}, Tuple{K}, Tuple{CodecLZO.HashMap{K, V}, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64}} where {K&lt;:Integer, V}" href="#CodecLZO.replace_all_matching!-Union{Tuple{V}, Tuple{K}, Tuple{CodecLZO.HashMap{K, V}, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64}} where {K&lt;:Integer, V}"><code>CodecLZO.replace_all_matching!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_all_matching!(h::HashMap, input, input_start, output, output_start)</code></pre><p>Count the number of elements at the start of <code>input</code> that match the elements at the start of <code>output</code>, putting the matching indices of <code>input</code> as values into <code>h</code> keyed by the <code>K</code> integer read from <code>input</code> at that index.</p><p>Returns the number of matching bytes found (not necessarily equal to the number of <code>K</code>s put into <code>h</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/hashmap.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.resize_front!-Tuple{CodecLZO.ModuloBuffer, Integer}" href="#CodecLZO.resize_front!-Tuple{CodecLZO.ModuloBuffer, Integer}"><code>CodecLZO.resize_front!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resize_front!(buffer::ModuloBuffer, n::Integer)::ModuloBuffer</code></pre><p>Resize <code>buffer</code> to a capacity of <code>n</code> elements by adjusting the location of the front of the buffer.</p><p>If <code>n &lt; capacity(buffer)</code>, only the <em>last</em> <code>n</code> elements of <code>buffer</code> will be retained.</p><p>Attempts to avoid allocating new memory by manipulating and resizing the internal vector in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/modulobuffer.jl#L167-L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.shift_copy!" href="#CodecLZO.shift_copy!"><code>CodecLZO.shift_copy!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shift_copy!(buffer::ModuloBuffer, source, i, sink, j, [n])::Tuple{Int,Int}</code></pre><p>Copy <code>n</code> elements <code>source</code> starting at <code>i</code> to the back of <code>buffer</code>, evicting elements from the front of <code>buffer</code> to <code>sink</code> starting at <code>j</code>.</p><p><code>source</code> must be a valid source for the <code>copyto!</code> method, and <code>sink</code> must be a valid destination.</p><p>If not specified, <code>n</code> defaults to the minimum of the capacity of <code>buffer</code>, the number of elements that can be copied from <code>source</code>, and the amount of free space left in <code>sink</code>.</p><p>If <code>n &lt;= capacity(buffer) - length(buffer)</code>, then all <code>n</code> elements will be copied into the available space in <code>buffer</code> and no elements will be evicted from the front of <code>buffer</code> into <code>sink</code>.</p><p>Returns a tuple of the number of elements copied from <code>source</code> and the number of elements evicted from <code>buffer</code> and copied to <code>sink</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/modulobuffer.jl#L186-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.state-Tuple{LZO1X1CompressorCodec}" href="#CodecLZO.state-Tuple{LZO1X1CompressorCodec}"><code>CodecLZO.state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">state(codec)::MatchingState</code></pre><p>Determine the state of the codec from the command in the buffer.</p><p>The state of the codec can be one of:</p><ul><li><code>FIRST_LITERAL</code>`: in the middle of recording the first literal copy command from the input (the initial state);</li><li><code>LITERAL</code>: in the middle of writing a literal copy command to the output; or</li><li><code>HISTORY</code>: in the middle of writing a history copy command to the output.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_stream_compression.jl#L76-L85">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.unsafe_decode_run-Tuple{Ptr{UInt8}, Integer, Integer}" href="#CodecLZO.unsafe_decode_run-Tuple{Ptr{UInt8}, Integer, Integer}"><code>CodecLZO.unsafe_decode_run</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_decode_run(p::Ptr{UInt8}, i, bits)::Tuple{Int, Int}</code></pre><p>Decode the length of the run in bytes and the number of bytes to copy from the memory address pointed to by <code>p</code> offset by <code>i</code> given a mask of <code>bits</code> bits.</p><p>This method is &quot;unsafe&quot; in that it will not stop reading from memory addresses after <code>p</code> until it finds a non-zero byte, whatever the consequences.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.unsafe_encode_run!" href="#CodecLZO.unsafe_encode_run!"><code>CodecLZO.unsafe_encode_run!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_encode_run!(p::Ptr{UInt8}, len, bits, [i=1])::Int</code></pre><p>Emit the number of zero bytes necessary to encode a length <code>len</code> in a command expecting <code>bits</code> leading bits, returning the number of bytes written to the output.</p><p>Literal and copy lengths are always encoded as either a single byte or a sequence of three or more bytes. If <code>len &lt; (1 &lt;&lt; bits)</code>, the length will be encoded in the lower <code>bits</code> bits of the starting byte of <code>output</code> so the return will be 0. Otherwise, the return will be the number of additional bytes needed to encode the length. The returned number of bytes does not include the zeros in the first byte (the command) used to signal that a run encoding follows, but it does include the remainder.</p><p>This method is &quot;unsafe&quot; in that it does not check if <code>p</code> points to an area of memory large enough to hold the resulting run before clobbering it.</p><p>Note: the argument <code>len</code> is expected to be the <em>adjusted length</em> for the command. Literals use an adjusted length of <code>len = length(literal) - 3</code> and copy commands use an adjusted literal length of <code>len = length(copy) - 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/commands.jl#L74-L84">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.unsafe_lzo_compress!" href="#CodecLZO.unsafe_lzo_compress!"><code>CodecLZO.unsafe_lzo_compress!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_lzo_compress!(dest::Vector{UInt8}, src, [working_memory=zeros(UInt8, 1&lt;&lt;12)])::Int</code></pre><p>Compress <code>src</code> to <code>dest</code> using the LZO 1X1 algorithm.</p><p>The method is &quot;unsafe&quot; in that it does not check to see if the compressed output can fit into <code>dest</code> before proceeding, and may write out of bounds or crash your program if the number of bytes required to compress <code>src</code> is larger than the number of bytes available in <code>dest</code>. The method returns the number of bytes written to <code>dest</code>, which may be greater than <code>length(dest)</code>.</p><p>Pass <code>working_memory</code>, a <code>Vector{UInt8}</code> with <code>length(working_memory) &gt;= 1&lt;&lt;12</code>, to reuse pre-allocated memory required by the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_fast_compression.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.unsafe_lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}" href="#CodecLZO.unsafe_lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.unsafe_lzo_decompress!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_lzo_decompress!(dest::Vector{UInt8}, src)::Int</code></pre><p>Decompress <code>src</code> to <code>dest</code> using the LZO 1X1 algorithm.</p><p>The method is &quot;unsafe&quot; in that it does not check to see if the decompressed output can fit into <code>dest</code> before proceeding, and may write out of bounds or crash your program if the number of bytes required to decompress <code>src</code> is larger than the number of bytes available in <code>dest</code>. The method returns the number of bytes written to <code>dest</code>, which may be greater than <code>length(dest)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/2e3e00f81fdebe2bac6ea730229c8be44994e998/src/lzo1x1_fast_decompression.jl#L36-L42">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Tuesday 9 January 2024 22:51">Tuesday 9 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

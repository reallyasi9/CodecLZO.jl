<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · CodecLZO.jl</title><meta name="title" content="Home · CodecLZO.jl"/><meta property="og:title" content="Home · CodecLZO.jl"/><meta property="twitter:title" content="Home · CodecLZO.jl"/><meta name="description" content="Documentation for CodecLZO.jl."/><meta property="og:description" content="Documentation for CodecLZO.jl."/><meta property="twitter:description" content="Documentation for CodecLZO.jl."/><meta property="og:url" content="https://reallyasi9.github.io/CodecLZO.jl/"/><meta property="twitter:url" content="https://reallyasi9.github.io/CodecLZO.jl/"/><link rel="canonical" href="https://reallyasi9.github.io/CodecLZO.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CodecLZO.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/reallyasi9/CodecLZO.jl/blob/development/docs/src/index.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CodecLZO"><a class="docs-heading-anchor" href="#CodecLZO">CodecLZO</a><a id="CodecLZO-1"></a><a class="docs-heading-anchor-permalink" href="#CodecLZO" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/reallyasi9/CodecLZO.jl">CodecLZO</a>.</p><ul><li><a href="#CodecLZO.HashMap"><code>CodecLZO.HashMap</code></a></li><li><a href="#CodecLZO.LZO1X1CompressorCodec"><code>CodecLZO.LZO1X1CompressorCodec</code></a></li><li><a href="#CodecLZO.LZO1X1DecompressorCodec"><code>CodecLZO.LZO1X1DecompressorCodec</code></a></li><li><a href="#CodecLZO.LZO1X1FastCompressorCodec"><code>CodecLZO.LZO1X1FastCompressorCodec</code></a></li><li><a href="#CodecLZO.LZO1X1FastDecompressorCodec"><code>CodecLZO.LZO1X1FastDecompressorCodec</code></a></li><li><a href="#CodecLZO.PassThroughFIFO"><code>CodecLZO.PassThroughFIFO</code></a></li><li><a href="#CodecLZO.count_matching-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>CodecLZO.count_matching</code></a></li><li><a href="#CodecLZO.encode_run!-Tuple{Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Int64, Int64}"><code>CodecLZO.encode_run!</code></a></li><li><a href="#CodecLZO.lzo_compress"><code>CodecLZO.lzo_compress</code></a></li><li><a href="#CodecLZO.lzo_compress!"><code>CodecLZO.lzo_compress!</code></a></li><li><a href="#CodecLZO.lzo_decompress-Tuple{AbstractVector{UInt8}}"><code>CodecLZO.lzo_decompress</code></a></li><li><a href="#CodecLZO.lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.lzo_decompress!</code></a></li><li><a href="#CodecLZO.multiplicative_hash-Union{Tuple{T}, Tuple{T, Integer, Int64}} where T&lt;:Integer"><code>CodecLZO.multiplicative_hash</code></a></li><li><a href="#CodecLZO.prepend!-Tuple{CodecLZO.PassThroughFIFO, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Integer, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Integer, Integer}"><code>CodecLZO.prepend!</code></a></li><li><a href="#CodecLZO.reinterpret_get-Union{Tuple{T}, Tuple{Type{T}, AbstractVector{UInt8}}, Tuple{Type{T}, AbstractVector{UInt8}, Int64}} where T&lt;:Integer"><code>CodecLZO.reinterpret_get</code></a></li><li><a href="#CodecLZO.reinterpret_next-Union{Tuple{T}, Tuple{T, AbstractVector{UInt8}}, Tuple{T, AbstractVector{UInt8}, Int64}} where T&lt;:Integer"><code>CodecLZO.reinterpret_next</code></a></li><li><a href="#CodecLZO.replace_all_matching!-Union{Tuple{V}, Tuple{K}, Tuple{CodecLZO.HashMap{K, V}, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64}} where {K&lt;:Integer, V}"><code>CodecLZO.replace_all_matching!</code></a></li><li><a href="#CodecLZO.unsafe_lzo_compress!"><code>CodecLZO.unsafe_lzo_compress!</code></a></li><li><a href="#CodecLZO.unsafe_lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.unsafe_lzo_decompress!</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.HashMap" href="#CodecLZO.HashMap"><code>CodecLZO.HashMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HashMap{K,V}</code></pre><p>A super-fast dictionary-like hash table of fixed size for integer keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/hashmap.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LZO1X1CompressorCodec" href="#CodecLZO.LZO1X1CompressorCodec"><code>CodecLZO.LZO1X1CompressorCodec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LZO1X1CompressorCodec &lt;: TranscodingStreams.Codec</code></pre><p>A struct that compresses data according to the 1X1 version of the LZO algorithm.</p><p>The LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm defined by:</p><ul><li>A lookback dictionary implemented as a hash map with a maximum of size of <code>1&lt;&lt;12 = 4096</code> elements;</li><li>A 4-byte history lookup window that scans the input with a skip distance that increases linearly with the number of misses;</li><li>A maximum lookback distance of <code>0b11000000_00000000 - 1 = 49151</code> bytes;</li></ul><p>The C implementation of LZO defined by liblzo2 requires that all compressable information be loaded in working memory at once, and is therefore not adaptable to streaming as required by TranscodingStreams. The C library version claims to use only a 4096-byte hash map as additional working memory, but it also requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable <em>a priori</em> but can be larger than the uncompressed data by a factor of roughly 256/255. This implementation needs to keep 49151 bytes of input history in memory in addition to the 4096-byte hash map, but only expands the output as necessary during compression.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_stream_compression.jl#L23-L34">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LZO1X1DecompressorCodec" href="#CodecLZO.LZO1X1DecompressorCodec"><code>CodecLZO.LZO1X1DecompressorCodec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LZO1X1DecompressorCodec &lt;: TranscodingStreams.Codec</code></pre><p>A struct that decompresses data according to the 1X1 version of the LZO algorithm.</p><p>The LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm. Compressed streams consist of alternating encoded instructions and sequences of literal values. The encoded instructions tell the decompressor to either:</p><ol><li>copy a sequence of bytes of a particular length directly from the input to the output (literal copy), or</li><li>look back a certain distance in the already returned output and copy a sequence of bytes of a particular length from the output to the output again.</li></ol><p>For implementation purposes, this decompressor uses a buffer of 49151 bytes to store output. This is equal to the maximum lookback distance of the LZO 1X1 algorithm.</p><p>The C implementation of LZO defined by liblzo2 requires that all decompressed information be available in working memory at once, and is therefore not adaptable to streaming as required by TranscodingStreams. The C library version claims to use no additional working memory, but it requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable <em>a priori</em> but can be larger than the compressed data by a factor of roughly 255. This implementation needs to keep 49151 bytes of output history in memory while decompressing, equal to the maximum lookback distance of the LZO 1x1 algorithm, and a small number of bytes to keep track of the command being processed in case the command is broken between multiple reads from the input memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_stream_decompression.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LZO1X1FastCompressorCodec" href="#CodecLZO.LZO1X1FastCompressorCodec"><code>CodecLZO.LZO1X1FastCompressorCodec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LZO1X1FastCompressorCodec &lt;: TranscodingStreams.Codec</code></pre><p>A struct that compresses data using the liblzo2 version version of the LZO 1X1 algorithm.</p><p>The LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm defined by:</p><ul><li>A lookback dictionary implemented as a hash map with a maximum of size of <code>1&lt;&lt;16 = 65536</code> elements;</li><li>A 4-byte history lookup window that scans the input with a skip distance that increases linearly with the number of misses;</li><li>A maximum lookback distance of <code>0b11000000_00000000 - 1 = 49151</code> bytes;</li></ul><p>The C implementation of LZO defined by liblzo2 requires that all compressable information be loaded in working memory at once. The C library version claims to use only a 4096-byte hash map as additional working memory, but it also requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable <em>a priori</em> but can be larger than the uncompressed data by a factor of roughly 256/255. This implementation uses an expanding input buffer that waits until all input is available before processing, eliminating the usefulness of the TranscodingStreams interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_fast_compression.jl#L8-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.LZO1X1FastDecompressorCodec" href="#CodecLZO.LZO1X1FastDecompressorCodec"><code>CodecLZO.LZO1X1FastDecompressorCodec</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">LZO1X1FastDecompressorCodec &lt;: TranscodingStreams.Codec</code></pre><p>A struct that decompresses data using liblzo1 library version of the LZO 1X1 algorithm.</p><p>The LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm. Compressed streams consist of alternating encoded instructions and sequences of literal values. The encoded instructions tell the decompressor to either:</p><ol><li>copy a sequence of bytes of a particular length directly from the input to the output (literal copy), or</li><li>look back a certain distance in the already returned output and copy a sequence of bytes of a particular length from the output to the output again.</li></ol><p>The C implementation of LZO defined by liblzo2 requires that all decompressed information be available in working memory at once, and therefore does not take advantage of the memory savings allowed by TranscodingStreams. The C library version claims to use no additional working memory, but it requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable <em>a priori</em> but can be larger than the compressed data by a factor of roughly 255. This implementation reports a very large memory requirement with <code>TranscodingStreams.minoutsize</code> to account for this.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_fast_decompression.jl#L2-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.PassThroughFIFO" href="#CodecLZO.PassThroughFIFO"><code>CodecLZO.PassThroughFIFO</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PassThroughFIFO &lt;: AbstractVector{UInt8}</code></pre><p>A FIFO (first in, first out) that buffers data pushed into it and pushes out older data to a sink when new data is prepended.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/passthroughfifo.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.count_matching-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T" href="#CodecLZO.count_matching-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T"><code>CodecLZO.count_matching</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">count_matching(a::AbstractVector, b::AbstractVector)</code></pre><p>Count the number of elements at the start of <code>a</code> that match the elements at the start of <code>b</code>.</p><p>Equivalent to <code>findfirst(a .!= b)</code>, but faster and limiting itself to the first <code>min(length(a), length(b))</code> elements.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/memory_management.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.encode_run!-Tuple{Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Int64, Int64}" href="#CodecLZO.encode_run!-Tuple{Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Int64, Int64}"><code>CodecLZO.encode_run!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_written = encode_run(output, start_index, len, bits)</code></pre><p>Emit the number of zero bytes necessary to encode a length <code>len</code> in a command expecting <code>bits</code> leading bits.</p><p>Literal and copy lengths are always encoded as either a single byte or a sequence of three or more bytes. If <code>len &lt; (1 &lt;&lt; bits)</code>, the length will be encoded in the lower <code>bits</code> bits of the starting byte of <code>output</code> so the return will be 0. Otherwise, the return will be the number of additional bytes needed to encode the length. The returned number of bytes does not include the zeros in the first byte (the command) used to signal that a run encoding follows, but it does include the remainder.</p><p>Note: the argument <code>len</code> is expected to be the <em>adjusted length</em> for the command. Literals use an adjusted length of <code>len = length(literal) - 3</code> and copy commands use an adjusted literal length of <code>len = length(copy) - 2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_stream_compression.jl#L136-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.lzo_compress" href="#CodecLZO.lzo_compress"><code>CodecLZO.lzo_compress</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lzo_compress(src, [working_memory=zeros(UInt8, 1&lt;&lt;12)])::Vector{UInt8}</code></pre><p>Compress <code>src</code> using the LZO 1X1 algorithm.</p><p>Returns a compressed version of <code>src</code>.</p><p>Pass <code>working_memory</code>, a <code>Vector{UInt8}</code> with <code>length(working_memory) &gt;= 1&lt;&lt;12</code>, to reuse pre-allocated memory required by the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_fast_compression.jl#L93-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.lzo_compress!" href="#CodecLZO.lzo_compress!"><code>CodecLZO.lzo_compress!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lzo_compress!(dest::Vector{UInt8}, src, [working_memory=zeros(UInt8, 1&lt;&lt;12)])</code></pre><p>Compress <code>src</code> to <code>dest</code> using the LZO 1X1 algorithm.</p><p>The destination vector <code>dest</code> will be resized to fit the compressed data if necessary. Returns the modified <code>dest</code>.</p><p>Pass <code>working_memory</code>, a <code>Vector{UInt8}</code> with <code>length(working_memory) &gt;= 1&lt;&lt;12</code>, to reuse pre-allocated memory required by the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_fast_compression.jl#L70-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}" href="#CodecLZO.lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.lzo_decompress!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lzo_decompress!(dest::Vector{UInt8}, src)</code></pre><p>Decompress <code>src</code> to <code>dest</code> using the LZO 1X1 algorithm.</p><p>The destination vector <code>dest</code> will be resized to fit the decompressed data if necessary. Returns the modified <code>dest</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_fast_decompression.jl#L56-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.lzo_decompress-Tuple{AbstractVector{UInt8}}" href="#CodecLZO.lzo_decompress-Tuple{AbstractVector{UInt8}}"><code>CodecLZO.lzo_decompress</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lzo_decompress(src)::Vector{UInt8}</code></pre><p>Decompress <code>src</code> using the LZO 1X1 algorithm.</p><p>Returns a decompressed version of <code>src</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_fast_decompression.jl#L90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.multiplicative_hash-Union{Tuple{T}, Tuple{T, Integer, Int64}} where T&lt;:Integer" href="#CodecLZO.multiplicative_hash-Union{Tuple{T}, Tuple{T, Integer, Int64}} where T&lt;:Integer"><code>CodecLZO.multiplicative_hash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">multiplicative_hash(value, magic_number, bits, [mask::V = typemax(UInt64)])</code></pre><p>Hash <code>value</code> into a type <code>V</code> using multiplicative hashing.</p><p>This method performs <code>floor((value * magic_number % W) / (W / M))</code> where <code>W = 2^64</code>, <code>M = 2^m</code>, and <code>magic_number</code> is relatively prime to <code>W</code>, is large, and has a good mix of 1s and 0s in its binary representation. In modulo <code>2^64</code> arithmetic, this becomes <code>(value * magic_number) &gt;&gt;&gt; m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/hashmap.jl#L30-L38">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.prepend!-Tuple{CodecLZO.PassThroughFIFO, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Integer, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Integer, Integer}" href="#CodecLZO.prepend!-Tuple{CodecLZO.PassThroughFIFO, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Integer, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Integer, Integer}"><code>CodecLZO.prepend!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prepend!(p::PassThroughFIFO, source, source_start, sink, sink_start)</code></pre><p>Push as much of <code>source</code> (starting at <code>source_start</code>) into the FIFO as it can hold, pushing out stored data to <code>sink</code> (starting at <code>sink_start</code>).</p><p>Until <code>p</code> is full, elements from <code>source</code> will be added to the FIFO and no elements will be pushed out to <code>sink</code>. Once <code>p</code> is full, elements of <code>source</code> up to <code>capacity(p)</code> will be added to the FIFO and the older elements will be pushed to <code>sink</code>.</p><p>Returns a tuple of the number of elements read from <code>source</code> and the number of elements written to <code>sink</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/passthroughfifo.jl#L37-L45">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.reinterpret_get-Union{Tuple{T}, Tuple{Type{T}, AbstractVector{UInt8}}, Tuple{Type{T}, AbstractVector{UInt8}, Int64}} where T&lt;:Integer" href="#CodecLZO.reinterpret_get-Union{Tuple{T}, Tuple{Type{T}, AbstractVector{UInt8}}, Tuple{Type{T}, AbstractVector{UInt8}, Int64}} where T&lt;:Integer"><code>CodecLZO.reinterpret_get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinterpret_get(T::Type, input::AbstractVector{UInt8}, [index::Int = 1])::T</code></pre><p>Reinterpret bytes from <code>input</code> as an LE-ordered value of type <code>T</code>, optionally starting at <code>index</code>. This tries to be faster than <code>reinterpret(T, input[index:index+sizeof(T)-1])</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/memory_management.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.reinterpret_next-Union{Tuple{T}, Tuple{T, AbstractVector{UInt8}}, Tuple{T, AbstractVector{UInt8}, Int64}} where T&lt;:Integer" href="#CodecLZO.reinterpret_next-Union{Tuple{T}, Tuple{T, AbstractVector{UInt8}}, Tuple{T, AbstractVector{UInt8}, Int64}} where T&lt;:Integer"><code>CodecLZO.reinterpret_next</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reinterpret_next(previous::T, input::AbstractVector{UInt8}, [index::Int = 1])::T</code></pre><p>Get the byte from <code>input</code> at <code>index</code> and push it to the LSB of <code>previous</code>, rotating off the MSB. This tries to be faster than doing <code>reinterpret(T, input[index:index+sizeof(T)-1])</code> twice by reusing the already read LSBs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/memory_management.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.replace_all_matching!-Union{Tuple{V}, Tuple{K}, Tuple{CodecLZO.HashMap{K, V}, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64}} where {K&lt;:Integer, V}" href="#CodecLZO.replace_all_matching!-Union{Tuple{V}, Tuple{K}, Tuple{CodecLZO.HashMap{K, V}, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64}} where {K&lt;:Integer, V}"><code>CodecLZO.replace_all_matching!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">replace_all_matching!(h::HashMap, input, input_start, output, output_start)</code></pre><p>Count the number of elements at the start of <code>input</code> that match the elements at the start of <code>output</code>, putting the matching indices of <code>input</code> as values into <code>h</code> keyed by the <code>K</code> integer read from <code>input</code> at that index.</p><p>Returns the number of matching bytes found (not necessarily equal to the number of <code>K</code>s put into <code>h</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/hashmap.jl#L59-L65">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.unsafe_lzo_compress!" href="#CodecLZO.unsafe_lzo_compress!"><code>CodecLZO.unsafe_lzo_compress!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unsafe_lzo_compress!(dest::Vector{UInt8}, src, [working_memory=zeros(UInt8, 1&lt;&lt;12)])::Int</code></pre><p>Compress <code>src</code> to <code>dest</code> using the LZO 1X1 algorithm.</p><p>The method is &quot;unsafe&quot; in that it does not check to see if the compressed output can fit into <code>dest</code> before proceeding, and may write out of bounds or crash your program if the number of bytes required to compress <code>src</code> is larger than the number of bytes available in <code>dest</code>. The method returns the number of bytes written to <code>dest</code>, which may be greater than <code>length(dest)</code>.</p><p>Pass <code>working_memory</code>, a <code>Vector{UInt8}</code> with <code>length(working_memory) &gt;= 1&lt;&lt;12</code>, to reuse pre-allocated memory required by the algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_fast_compression.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodecLZO.unsafe_lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}" href="#CodecLZO.unsafe_lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}"><code>CodecLZO.unsafe_lzo_decompress!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unsafe_lzo_decompress!(dest::Vector{UInt8}, src)::Int</code></pre><p>Decompress <code>src</code> to <code>dest</code> using the LZO 1X1 algorithm.</p><p>The method is &quot;unsafe&quot; in that it does not check to see if the decompressed output can fit into <code>dest</code> before proceeding, and may write out of bounds or crash your program if the number of bytes required to decompress <code>src</code> is larger than the number of bytes available in <code>dest</code>. The method returns the number of bytes written to <code>dest</code>, which may be greater than <code>length(dest)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/reallyasi9/CodecLZO.jl/blob/4360fe40940e65c3005a7438a8df691be5feeaeb/src/lzo1x1_fast_decompression.jl#L36-L42">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Monday 11 December 2023 19:20">Monday 11 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

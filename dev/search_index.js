var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CodecLZO","category":"page"},{"location":"#CodecLZO","page":"Home","title":"CodecLZO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CodecLZO.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CodecLZO]","category":"page"},{"location":"#CodecLZO.HashMap","page":"Home","title":"CodecLZO.HashMap","text":"HashMap{K,V}\n\nA super-fast dictionary-like hash table of fixed size for integer keys.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZO.LZO1X1CompressorCodec","page":"Home","title":"CodecLZO.LZO1X1CompressorCodec","text":"LZO1X1CompressorCodec <: TranscodingStreams.Codec\n\nA struct that compresses data according to the 1X1 version of the LZO algorithm.\n\nThe LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm defined by:\n\nA lookback dictionary implemented as a hash map with a maximum of size of 1<<12 = 4096 elements;\nA 4-byte history lookup window that scans the input with a skip distance that increases linearly with the number of misses;\nA maximum lookback distance of 0b11000000_00000000 - 1 = 49151 bytes;\n\nThe C implementation of LZO defined by liblzo2 requires that all compressable information be loaded in working memory at once, and is therefore not adaptable to streaming as required by TranscodingStreams. The C library version claims to use only a 4096-byte hash map as additional working memory, but it also requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable a priori but can be larger than the uncompressed data by a factor of roughly 256/255. This implementation needs to keep 49151 bytes of input history in memory in addition to the 4096-byte hash map, but only expands the output as necessary during compression.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZO.LZO1X1DecompressorCodec","page":"Home","title":"CodecLZO.LZO1X1DecompressorCodec","text":"LZO1X1DecompressorCodec <: TranscodingStreams.Codec\n\nA struct that decompresses data according to the 1X1 version of the LZO algorithm.\n\nThe LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm. Compressed streams consist of alternating encoded instructions and sequences of literal values. The encoded instructions tell the decompressor to either:\n\ncopy a sequence of bytes of a particular length directly from the input to the output (literal copy), or\nlook back a certain distance in the already returned output and copy a sequence of bytes of a particular length from the output to the output again.\n\nFor implementation purposes, this decompressor uses a buffer of 49151 bytes to store output. This is equal to the maximum lookback distance of the LZO 1X1 algorithm.\n\nThe C implementation of LZO defined by liblzo2 requires that all decompressed information be available in working memory at once, and is therefore not adaptable to streaming as required by TranscodingStreams. The C library version claims to use no additional working memory, but it requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable a priori but can be larger than the compressed data by a factor of roughly 255. This implementation needs to keep 49151 bytes of output history in memory while decompressing, equal to the maximum lookback distance of the LZO 1x1 algorithm, and a small number of bytes to keep track of the command being processed in case the command is broken between multiple reads from the input memory.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZO.PassThroughFIFO","page":"Home","title":"CodecLZO.PassThroughFIFO","text":"PassThroughFIFO <: AbstractVector{UInt8}\n\nA FIFO (first in, first out) that buffers data pushed into it and pushes out older data to a sink when new data is prepended.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZO.count_matching-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}}} where T","page":"Home","title":"CodecLZO.count_matching","text":"count_matching(a::AbstractVector, b::AbstractVector)\n\nCount the number of elements at the start of a that match the elements at the start of b.\n\nEquivalent to findfirst(a .!= b), but faster and limiting itself to the first min(length(a), length(b)) elements.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.encode_run!-Tuple{Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Int64, Int64}","page":"Home","title":"CodecLZO.encode_run!","text":"n_written = encode_run(output, start_index, len, bits)\n\nEmit the number of zero bytes necessary to encode a length len in a command expecting bits leading bits.\n\nLiteral and copy lengths are always encoded as either a single byte or a sequence of three or more bytes. If len < (1 << bits), the length will be encoded in the lower bits bits of the starting byte of output so the return will be 0. Otherwise, the return will be the number of additional bytes needed to encode the length. The returned number of bytes does not include the zeros in the first byte (the command) used to signal that a run encoding follows, but it does include the remainder.\n\nNote: the argument len is expected to be the adjusted length for the command. Literals use an adjusted length of len = length(literal) - 3 and copy commands use an adjusted literal length of len = length(copy) - 2.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.multiplicative_hash-Union{Tuple{T}, Tuple{T, Integer, Int64}} where T<:Integer","page":"Home","title":"CodecLZO.multiplicative_hash","text":"multiplicative_hash(value, magic_number, bits, [mask::V = typemax(UInt64)])\n\nHash value into a type V using multiplicative hashing.\n\nThis method performs floor((value * magic_number % W) / (W / M)) where W = 2^64, M = 2^m, and magic_number is relatively prime to W, is large, and has a good mix of 1s and 0s in its binary representation. In modulo 2^64 arithmetic, this becomes (value * magic_number) >>> m.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.prepend!-Tuple{CodecLZO.PassThroughFIFO, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Integer, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Integer, Integer}","page":"Home","title":"CodecLZO.prepend!","text":"prepend!(p::PassThroughFIFO, source, source_start, sink, sink_start)\n\nPush as much of source (starting at source_start) into the FIFO as it can hold, pushing out stored data to sink (starting at sink_start).\n\nUntil p is full, elements from source will be added to the FIFO and no elements will be pushed out to sink. Once p is full, elements of source up to capacity(p) will be added to the FIFO and the older elements will be pushed to sink.\n\nReturns a tuple of the number of elements read from source and the number of elements written to sink.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.reinterpret_get-Union{Tuple{T}, Tuple{Type{T}, AbstractVector{UInt8}}, Tuple{Type{T}, AbstractVector{UInt8}, Int64}} where T<:Integer","page":"Home","title":"CodecLZO.reinterpret_get","text":"reinterpret_get(T::Type, input::AbstractVector{UInt8}, [index::Int = 1])::T\n\nReinterpret bytes from input as an LE-ordered value of type T, optionally starting at index. This tries to be faster than reinterpret(T, input[index:index+sizeof(T)-1]).\n\n\n\n\n\n","category":"method"}]
}

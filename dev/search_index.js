var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CodecLZO","category":"page"},{"location":"#CodecLZO","page":"Home","title":"CodecLZO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CodecLZO.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CodecLZO]","category":"page"},{"location":"#CodecLZO.CommandPair","page":"Home","title":"CodecLZO.CommandPair","text":"CommandPair\n\nA mutable type representing both a history lookback copy and a literal copy.\n\nExcept for the first or last command, commands in LZO 1X1 always come in pairs: a history lookback always follows a literal, and if a literal copy of zero bytes is considered, a literal copy always follows a history lookback. This means commands can be efficiently stored, parsed, and encoded as pairs of commands.\n\nLiteral copies\n\nIn LZO1X, literal copies come in three varieties:\n\nLong copies\n\nLZO1X long copy commands begin with a byte with four high zero bits and four low potentially non-zero bits:\n\n`0000LLLL [Z zero bytes] [XXXXXXXX]`\n\nThe low four bits represent the length of the copy minus three. This can obviously only represent copies of length 3 to 18, so to encode longer copies, LZO1X uses the following encoding method:\n\nIf the first byte is non-zero, then length = 3 + L\nIf the first byte is zero, then length = 18 + Z × 255 + 0bXXXXXXXX\n\nThis means a length of 18 is encoded as [0b00001111], a length of 19 is encoded as [0b00000000, 0b00000001], a length of 274 is encoded as [0b00000000, 0b00000000, 0b00000001], and so on.\n\nShort copies\n\nThe long copy command cannot encode copies shorter than four bytes by design. If a literal of three or fewer bytes needs to be copied, it is encoded in the two least significant bits of the previous history lookback copy command. This works because literal copies and history lookback copies always alternate in LZO1X streams.\n\nFirst literal copies\n\nLZO1X streams always begin with a literal copy command of at least four bytes. Because the first command is always a literal copy, a special format is used to copy runs of literals that are between 18 and 238 bytes that compacts the command into a single byte. If the first byte of the stream has the following values, they are interpreted as the corresponding literal copy commands:\n\n0:15: Treat as a \"long copy\" encoding (see above).\n17:255: Treat as a copy of (byte - 17) literals.\n\nnote: Note\nThe first literal copy command of 17 is technically a valid first copy command, even though it signals a copy of zero bytes; however, if the first byte of an LZO stream is 17, the very next bytes must encode a long literal copy because there is no history available for a history copy command, and LZO does not have a way to encode a zero-byte history copy. A value of 16 in the first position is always invalid because it signals a history lookback copy command which cannot come before any literals are copied to the output.\n\nHistory lookback copies\n\nIn LZO1X, history lookback copies come in five varieties, the format of which is determined by the number of bytes copied, the lookback distance, and whether or not the previous command had a short literal copy tagged on the end:\n\nShort copy, short distance\n\nCopies of five to eight bytes with a lookback distance within 2048 bytes are encoded as two bytes, with bits encoding the length and distance. The command is to be interpreted in the following way (MSB first):\n\n`1LLDDDSS HHHHHHHH`\n\nThis means copy 5 + 0bLL bytes from a distance of 0b00000HHH_HHHHHDDD + 1.\n\nThe last two bits of the MSB instruct the decoder to copy 0 through 3 literals from the input to the output immediately following the history lookback copy.\n\nVery short copy, short distance\n\nCopies of three to four bytes with a lookback distance within 2048 bytes are encoded as two bytes, with bits encoding the length and distance. The command is to be interpreted in the following way (MSB first):\n\n`01LDDDSS HHHHHHHH`\n\nThis means copy 3 + 0bL from a distance of 0b00000HHH_HHHHHDDD + 1.\n\nThe last two bits of the MSB instruct the decoder to copy 0bSS literals from the input to the output immediately following the history lookback copy.\n\nnote: Note\nLZO1X checks for historical matches based on four byte runs, so a historical copy of three bytes can only occur if the byte that follows also matches, in which case the run is at least four bytes long. The reference LZO1X algorithm used in liblzo2 is a greedy algorithm, so it will only ever encode a three byte historical copy in the special case where the first three bytes of a sequence are repeated exactly once and are followed by a non-matching byte.\n\nAny length copy, short to medium distance\n\nCopies of any length greater than two with a lookback distance within 16384 bytes are incoded with at least three bytes and with as many as necessary to encode the run length. The command is to be interpreted in the following way (MSB first):\n\n`001LLLLL [Z zero bytes] [XXXXXXXX] EEEEEESS DDDDDDDD`\n\nThe lower five bits of the first byte represent the length of the copy minus two. To encode copies longer than 33 bytes, LZO1X uses the following encoding method:\n\nIf 0bLLLLL is non-zero, then length = 2 + 0bLLLLL\nIf 0bLLLLL is zero, then length = 33 + Z × 255 + 0bXXXXXXXX\n\nThe lookback distance is encoded in LE order in the last two bytes: that is, the last byte of the command holds the MSB of the distance, and the second-to-last byte holds the LSB of the distance. The distance is interpreted as distance = 0b00DDDDDD_DDEEEEEE + 1.\n\nThe last two bits of the second-to-last byte instruct the decoder to copy 0bSS literals from the input to the output immediately following the history lookback copy.\n\nAny length copy, long distance\n\nCopies of any length greater than two with a lookback distance between 16385 and 49151 bytes are incoded with at least three bytes and with as many as necessary to encode the run length. The command is to be interpreted in the following way (MSB first):\n\n`0001HLLL [Z zero bytes] [XXXXXXXX] EEEEEESS DDDDDDDD`\n\nAs with other variable length runs, LZO1X uses the following encoding method with this command:\n\nIf 0bLLL is non-zero, then length = 2 + 0bLLL\nIf 0bLLL is zero, then length = 9 + Z × 255 + 0bXXXXXXXX\n\nThe lookback distance is encoded with one bit in the first command byte (H), then in LE order in the last two bytes: that is, the last byte of the command holds the MSB of the distance, and the second-to-last byte holds the LSB of the distance. The distance is interpreted as distance = 16384 + 0b0HDDDDDD_DDEEEEEE.\n\nThe last two bits of the second-to-last byte instruct the decoder to copy 0bSS literals from the input to the output immediately following the history lookback copy.\n\ninfo: Special End-of-Stream Encoding\nEnd-of-stream is signaled by a history lookback copy of 3 bytes from a distance of 16384 bytes with no subsequent literal copies. This corresponds to two possible commands, so by convention the end-of-stream command uses the long distance version (0b00010001 0b00000000 0b00000000) while an actual copy of 3 bytes from a distance of 16384 uses the short distance version (0b00100001 0b00000000 0b00000000).\n\nnote: Note\nThe maximum lookback distance that LZO1X can encode is 16384 + 0b01111111_11111111 == 49151 bytes.\n\nShort copies from short distances following literal copies\n\nIf the previous history lookback command included a short literal copy (1 ≤ 0bSS ≤ 3, as encoded in the above commands), then a special two-byte command can be used to copy two bytes with a lookback distance within 1024 bytes. The command is to be interpreted in the following way (MSB first):\n\n`0000DDSS HHHHHHHH`\n\nThe number of bytes to copy is always length = 2, and the lookback distance is 0b000000HH_HHHHHHDD + 1.\n\nThe last two bits of the first byte instruct the decoder to copy 0bSS literals from the input to the output immediately following the history lookback copy.\n\nIf the previous command was a long literal copy (of four of more bytes), then the same two-byte command means something different: it encodes a three-byte copy with a lookback distance between 2049 and 3072 bytes. The command is interpreted the same as above, but length = 3 and distance = 0b000000HH_HHHHHHDD + 2049.\n\nnote: Note\nLZO1X checks for historical matches based on four byte runs, so a historical copy of two bytes can only occur if the two bytes that follow also match, in which case the run is at least four bytes long. The reference LZO1X algorithm used in liblzo2 is a greedy algorithm, so it will only ever encode a two byte historical copy in the special case where the first two bytes of a sequence repeat exactly once and are followed by a non-matching byte.\n\nSee also: decode and encode!.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZO.HashMap","page":"Home","title":"CodecLZO.HashMap","text":"HashMap{K,V}\n\nA super-fast dictionary-like hash table of fixed size for integer keys.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZO.LZO1X1CompressorCodec","page":"Home","title":"CodecLZO.LZO1X1CompressorCodec","text":"LZO1X1CompressorCodec(level::Int=5) <: TranscodingStreams.Codec\n\nA struct that compresses data according to the 1X1 version of the LZO algorithm.\n\nThe LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm defined by:\n\nA lookback dictionary implemented as a hash map with a maximum of size of 1<<12 = 4096 elements;\nA 4-byte history lookup window that scans the input with a skip distance that increases linearly with the number of misses;\nA maximum lookback distance of 0b11000000_00000000 - 1 = 49151 bytes;\n\nThe C implementation of LZO defined by liblzo2 requires that all compressable information be loaded in working memory at once, and is therefore not adaptable to streaming as required by TranscodingStreams. The C library version claims to use only a 4096-byte hash map as additional working memory, but it also requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable a priori but can be larger than the uncompressed data by a factor of roughly 256/255. This implementation needs to keep 98310 bytes of input history in memory in addition to the 4096-byte hash map, and also caches literal copies in an array that expands as necessary during compression.\n\nArguments:\n\nlevel::Int = 5: The speed/compression tradeoff paramter, with larger numbers representing slower compression at a higher compresison ratio. On a technical level, every pow(2, level) history misses increases by 1 the number of bytes skipped when searching for the next history match. The default (5) is recommended by the original liblzo2 authors as a good balance between speed and compression.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZO.LZO1X1FastCompressorCodec","page":"Home","title":"CodecLZO.LZO1X1FastCompressorCodec","text":"LZO1X1FastCompressorCodec <: TranscodingStreams.Codec\n\nA struct that compresses data using the liblzo2 version version of the LZO 1X1 algorithm.\n\nThe LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm defined by:\n\nA lookback dictionary implemented as a hash map with a maximum of size of 1<<16 = 65536 elements;\nA 4-byte history lookup window that scans the input with a skip distance that increases linearly with the number of misses;\nA maximum lookback distance of 0b11000000_00000000 - 1 = 49151 bytes;\n\nThe C implementation of LZO defined by liblzo2 requires that all compressable information be loaded in working memory at once. The C library version claims to use only a 4096-byte hash map as additional working memory, but it also requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable a priori but can be larger than the uncompressed data by a factor of roughly 256/255. This implementation uses an expanding input buffer that waits until all input is available before processing, eliminating the usefulness of the TranscodingStreams interface.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZO.LZO1X1FastDecompressorCodec","page":"Home","title":"CodecLZO.LZO1X1FastDecompressorCodec","text":"LZO1X1FastDecompressorCodec <: TranscodingStreams.Codec\n\nA struct that decompresses data using liblzo1 library version of the LZO 1X1 algorithm.\n\nThe LZO 1X1 algorithm is a Lempel-Ziv lossless compression algorithm. Compressed streams consist of alternating encoded instructions and sequences of literal values. The encoded instructions tell the decompressor to either:\n\ncopy a sequence of bytes of a particular length directly from the input to the output (literal copy), or\nlook back a certain distance in the already returned output and copy a sequence of bytes of a particular length from the output to the output again.\n\nThe C implementation of LZO defined by liblzo2 requires that all decompressed information be available in working memory at once, and therefore does not take advantage of the memory savings allowed by TranscodingStreams. The C library version claims to use no additional working memory, but it requires that a continuous space in memory be available to hold the entire output of the compressed data, the length of which is not knowable a priori but can be larger than the compressed data by a factor of roughly 255. This implementation reports a very large memory requirement with TranscodingStreams.minoutsize to account for this.\n\n\n\n\n\n","category":"type"},{"location":"#Base.copyto!-Tuple{CircularArrays.CircularVector{T} where T, Integer, TranscodingStreams.Memory, Integer, Integer}","page":"Home","title":"Base.copyto!","text":"copyto!(dest::CircularVector, do, src::Memory, so, N)\n\nCopy N elements from collection src start at the linear index so to array dest starting at the index do. Return dest.\n\nBecause CircularVectors have circular boundary conditions on the indices, the linear index do may be negative, zero, or greater than lastindex(dest), and the number of elements copied N may be greater than length(dest).\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.command_length","page":"Home","title":"CodecLZO.command_length","text":"command_length(command, [last_literal_length=0])::Int\n\nReturn the number of bytes in the encoded commands.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLZO.compute_run_remainder-Tuple{Integer, Integer}","page":"Home","title":"CodecLZO.compute_run_remainder","text":"compute_run_remainder(n, bits)::Tuple{Int, Int}\n\nCompute the number of bytes necessary to encode a run of length n given a first-byte mask of length bits, also returning the remainder byte.\n\nnote: Note\nThis method does not adjust n before computing the run length. Perform adjustments before calling this method.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.decode","page":"Home","title":"CodecLZO.decode","text":"decode(::Type{CommandPair}, data, [start_index=1; first_literal=false, last_literal_length=0])::Tuple{Int, CommandPair}\n\nDecode a CommandPair from a byte array data starting at start_index.\n\nReturns a tuple of the number of bytes read from data and the decoded CommandPair.\n\nPositional arguments\n\ndata: a linear-indexed collection of UInt8 values that has getindex(data, ::Integer) and lastindex(data) methods defined.\nstart_index::Integer = 1: where in data to begin decoding.\n\nKeyword arguments\n\nfirst_literal::Bool = false: if true, the decoding algorithm will ignore the history copy and use the special encoding for the first literal of the stream.\nlast_literal_length::Integer = 0: if 0-3, apply special decoding for the history copy to allow short copies.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLZO.decode_run","page":"Home","title":"CodecLZO.decode_run","text":"decode_run(input, bits::Integer, [start_index::Integer = 1])::Tuple{Int, Int}\n\nDecode the number of bytes in the encoding and the length of the run in bytes of the run in input given a mask of bits bits, optionally starting decoding at index start_index.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLZO.encode!","page":"Home","title":"CodecLZO.encode!","text":"encode!(data, cp::CommandPair, [start_index = 1; last_literal_length = 0])::Int\n\nEncode CommandPair cp to byte array data.\n\nReturns the number of bytes written to data or zero if the encoding failed.\n\nPositional arguments\n\ndata: a linear-indexed collection of UInt8 values that has setindex!(data, ::Integer) and lastindex(data) methods defined.\nstart_index::Integer = 1: where in data to begin decoding.\n\nKeyword arguments\n\nlast_literal_length::Integer = 0: if 0-3, apply special encoding for the history copy to allow short copies.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLZO.encode_run!","page":"Home","title":"CodecLZO.encode_run!","text":"encode_run!(output, len, bits, [start_index=1])::Int\n\nEmit the number of zero bytes necessary to encode a length len in a command expecting bits leading bits to output, optionally starting at index start_index, returning the number of bytes written.\n\nLiteral and history copy lengths are always encoded as either a single byte or a sequence of three or more bytes. If len < (1 << bits), the length will be encoded in the lower bits bits of the starting byte of output so the return will be 1. Otherwise, the return will be the number of bytes needed to encode the length.\n\nIf output is not large enough to hold the length of the run, this function returns 0 and output is unchanged.\n\nArguments:\n\noutput: The target array-like object that will be written to. The type only needs to implement setindex!(output, ::UInt8, ::Int) and lastindex(output).\nlen::Integer: The adjusted length to encode (see note).\nbits::Integer: The number of bits that makes up the length mask of the command.\nstart_index::Integer=1: Where to begin writing the encoded run in output.\n\nnote: Note\nThe argument len is expected to be the adjusted length for the command. Literals use an adjusted length of len = length(literal) - 3 and copy commands use an adjusted literal length of len = length(copy) - 2.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLZO.encode_run-Tuple{Integer, Integer}","page":"Home","title":"CodecLZO.encode_run","text":"encode_run(len::Integer, bits::Integer)::Vector{UInt8}\n\nEmit a vector of the number of zero bytes necessary to encode a length len in a command expecting bits leading bits.\n\nSee: encode_run!.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.lzo_compress","page":"Home","title":"CodecLZO.lzo_compress","text":"lzo_compress(src, [working_memory=zeros(UInt8, 1<<12)])::Vector{UInt8}\n\nCompress src using the LZO 1X1 algorithm.\n\nReturns a compressed version of src.\n\nPass working_memory, a Vector{UInt8} with length(working_memory) >= 1<<12, to reuse pre-allocated memory required by the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLZO.lzo_compress!","page":"Home","title":"CodecLZO.lzo_compress!","text":"lzo_compress!(dest::Vector{UInt8}, src, [working_memory=zeros(UInt8, 1<<12)])\n\nCompress src to dest using the LZO 1X1 algorithm.\n\nThe destination vector dest will be resized to fit the compressed data if necessary. Returns the modified dest.\n\nPass working_memory, a Vector{UInt8} with length(working_memory) >= 1<<12, to reuse pre-allocated memory required by the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLZO.lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}","page":"Home","title":"CodecLZO.lzo_decompress!","text":"lzo_decompress!(dest::Vector{UInt8}, src)\n\nDecompress src to dest using the LZO 1X1 algorithm.\n\nThe destination vector dest will be resized to fit the decompressed data if necessary. Returns the modified dest.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.lzo_decompress-Tuple{AbstractVector{UInt8}}","page":"Home","title":"CodecLZO.lzo_decompress","text":"lzo_decompress(src)::Vector{UInt8}\n\nDecompress src using the LZO 1X1 algorithm.\n\nReturns a decompressed version of src.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.match_length-Tuple{Any, Integer, Integer, Integer}","page":"Home","title":"CodecLZO.match_length","text":"match_length(v, i::Integer, j::Integer, N::Integer)::Int\n\nSearches v[i:i+N-1] for the last element that matches in v[j:j+N-1], returning the maximal length of the matching elements up to and including N.\n\nThe argument v need only implement getindex(v, ::Integer). If the search runs out of bounds, a BoundsError will be thrown. If no matches are found, 0 will be returned, and if no non-match is found, N will be returned.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.maxcopy!-Tuple{Any, Any, Any}","page":"Home","title":"CodecLZO.maxcopy!","text":"maxcopy!(dest, start_index, src)::Int\n\nCopy as much of src into dest starting at index start_index as possible.\n\nRequires lastindex(dest), length(src), and copyto!(dest, start_index, src, 1, ::Int) to be defined for dest and src types.\n\nReturns the number of bytes copied.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.multiplicative_hash-Union{Tuple{T}, Tuple{T, Integer, Int64}} where T<:Integer","page":"Home","title":"CodecLZO.multiplicative_hash","text":"multiplicative_hash(value, magic_number, bits, [mask::V = typemax(UInt64)])\n\nHash value into a type V using multiplicative hashing.\n\nThis method performs floor((value * magic_number % W) / (W / M)) where W = 2^64, M = 2^m, and magic_number is relatively prime to W, is large, and has a good mix of 1s and 0s in its binary representation. In modulo 2^64 arithmetic, this becomes (value * magic_number) >>> m.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.reinterpret_get-Union{Tuple{T}, Tuple{Type{T}, Any}, Tuple{Type{T}, Any, Integer}} where T<:Integer","page":"Home","title":"CodecLZO.reinterpret_get","text":"reinterpret_get(T::Type, input, [index::Integer = 1])::T\n\nReinterpret bytes from input as an LE-ordered value of type T, optionally starting at index. This tries to be faster than reinterpret(T, input[index:index+sizeof(T)-1]).\n\ninput can be anything that is linearly indexed and getindex(input, ::Int) returns a type S for which the operator |(::T, ::S) is defined.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.reinterpret_next-Union{Tuple{T}, Tuple{T, Any}, Tuple{T, Any, Integer}} where T<:Integer","page":"Home","title":"CodecLZO.reinterpret_next","text":"reinterpret_next(previous::T, input::AbstractVector{UInt8}, [index::Int = 1])::T\n\nGet the byte from input at index and push it to the LSB of previous, rotating off the MSB. This tries to be faster than doing reinterpret(T, input[index:index+sizeof(T)-1]) twice by reusing the already read LSBs.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.replace_all_matching!-Union{Tuple{V}, Tuple{K}, Tuple{CodecLZO.HashMap{K, V}, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64, Union{TranscodingStreams.Memory, AbstractVector{UInt8}}, Int64}} where {K<:Integer, V}","page":"Home","title":"CodecLZO.replace_all_matching!","text":"replace_all_matching!(h::HashMap, input, input_start, output, output_start)\n\nCount the number of elements at the start of input that match the elements at the start of output, putting the matching indices of input as values into h keyed by the K integer read from input at that index.\n\nReturns the number of matching bytes found (not necessarily equal to the number of Ks put into h).\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.state-Tuple{LZO1X1CompressorCodec}","page":"Home","title":"CodecLZO.state","text":"state(codec)::MatchingState\n\nReturn the state of the compressor.\n\nThe state can be one of:     - HISTORY: The codec is looking for the end of the historical match (i.e., the byte before the next literal).     - LITERAL: The codec is looking for the next historical match (i.e., the length of the current literal).     - COMMAND: The codec is writing a command sequence.     - FLUSH: The codec is flushing the literal buffer to output.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZO.unsafe_lzo_compress!","page":"Home","title":"CodecLZO.unsafe_lzo_compress!","text":"unsafe_lzo_compress!(dest::Vector{UInt8}, src, [working_memory=zeros(UInt8, 1<<12)])::Int\n\nCompress src to dest using the LZO 1X1 algorithm.\n\nThe method is \"unsafe\" in that it does not check to see if the compressed output can fit into dest before proceeding, and may write out of bounds or crash your program if the number of bytes required to compress src is larger than the number of bytes available in dest. The method returns the number of bytes written to dest, which may be greater than length(dest).\n\nPass working_memory, a Vector{UInt8} with length(working_memory) >= 1<<12, to reuse pre-allocated memory required by the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"#CodecLZO.unsafe_lzo_decompress!-Tuple{Vector{UInt8}, AbstractVector{UInt8}}","page":"Home","title":"CodecLZO.unsafe_lzo_decompress!","text":"unsafe_lzo_decompress!(dest::Vector{UInt8}, src)::Int\n\nDecompress src to dest using the LZO 1X1 algorithm.\n\nThe method is \"unsafe\" in that it does not check to see if the decompressed output can fit into dest before proceeding, and may write out of bounds or crash your program if the number of bytes required to decompress src is larger than the number of bytes available in dest. The method returns the number of bytes written to dest, which may be greater than length(dest).\n\n\n\n\n\n","category":"method"}]
}
